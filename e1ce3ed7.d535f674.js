(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{89:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return b})),t.d(a,"metadata",(function(){return i})),t.d(a,"toc",(function(){return s})),t.d(a,"default",(function(){return o}));var n=t(3),r=t(7),l=(t(0),t(97)),b={title:"Tidy Function API",sidebar_label:"Tidy Functions"},i={unversionedId:"api/tidy",id:"api/tidy",isDocsHomePage:!1,title:"Tidy Function API",description:"Tidy functions are the main function used in a tidy(...) flow. These are the primary functions to be used when wrangling data. They expect their input to either be a flat list of items.",source:"@site/docs/api/tidy.md",slug:"/api/tidy",permalink:"/tidy/docs/api/tidy",editUrl:"https://github.com/pbeshai/tidy/docs/api/tidy.md",version:"current",lastUpdatedBy:"Peter Beshai",lastUpdatedAt:1614798472,sidebar_label:"Tidy Functions",sidebar:"docs",previous:{title:"Moving Average Examples",permalink:"/tidy/docs/examples/moving_average_example"},next:{title:"groupBy API",permalink:"/tidy/docs/api/groupby"}},s=[{value:"tidy",id:"tidy",children:[{value:"Parameters",id:"parameters",children:[]},{value:"Usage",id:"usage",children:[]}]},{value:"addItems / addRows",id:"additems--addrows",children:[{value:"Parameters",id:"parameters-1",children:[]},{value:"Usage",id:"usage-1",children:[]}]},{value:"arrange / sort",id:"arrange--sort",children:[{value:"Parameters",id:"parameters-2",children:[]},{value:"Usage",id:"usage-2",children:[]}]},{value:"complete",id:"complete",children:[{value:"Parameters",id:"parameters-3",children:[]},{value:"Usage",id:"usage-3",children:[]}]},{value:"count",id:"count",children:[{value:"Parameters",id:"parameters-4",children:[]},{value:"Usage",id:"usage-4",children:[]}]},{value:"debug",id:"debug",children:[{value:"Parameters",id:"parameters-5",children:[]},{value:"Usage",id:"usage-5",children:[]}]},{value:"distinct",id:"distinct",children:[{value:"Parameters",id:"parameters-6",children:[]},{value:"Usage",id:"usage-6",children:[]}]},{value:"expand",id:"expand",children:[{value:"Parameters",id:"parameters-7",children:[]},{value:"Usage",id:"usage-7",children:[]}]},{value:"fill",id:"fill",children:[{value:"Parameters",id:"parameters-8",children:[]},{value:"Usage",id:"usage-8",children:[]}]},{value:"filter",id:"filter",children:[{value:"Parameters",id:"parameters-9",children:[]},{value:"Usage",id:"usage-9",children:[]}]},{value:"groupBy",id:"groupby",children:[{value:"Usage",id:"usage-10",children:[]}]},{value:"innerJoin",id:"innerjoin",children:[{value:"Parameters",id:"parameters-10",children:[]},{value:"Usage",id:"usage-11",children:[]}]},{value:"leftJoin",id:"leftjoin",children:[{value:"Parameters",id:"parameters-11",children:[]},{value:"Usage",id:"usage-12",children:[]}]},{value:"map",id:"map",children:[{value:"Parameters",id:"parameters-12",children:[]},{value:"Usage",id:"usage-13",children:[]}]},{value:"mutate",id:"mutate",children:[{value:"Parameters",id:"parameters-13",children:[]},{value:"Usage",id:"usage-14",children:[]}]},{value:"mutateWithSummary",id:"mutatewithsummary",children:[{value:"Parameters",id:"parameters-14",children:[]},{value:"Usage",id:"usage-15",children:[]}]},{value:"rename",id:"rename",children:[{value:"Parameters",id:"parameters-15",children:[]},{value:"Usage",id:"usage-16",children:[]}]},{value:"replaceNully",id:"replacenully",children:[{value:"Parameters",id:"parameters-16",children:[]},{value:"Usage",id:"usage-17",children:[]}]},{value:"select / pick",id:"select--pick",children:[{value:"Parameters",id:"parameters-17",children:[]},{value:"Usage",id:"usage-18",children:[]}]},{value:"slice",id:"slice",children:[{value:"Parameters",id:"parameters-18",children:[]},{value:"Usage",id:"usage-19",children:[]}]},{value:"sliceHead",id:"slicehead",children:[{value:"Parameters",id:"parameters-19",children:[]},{value:"Usage",id:"usage-20",children:[]}]},{value:"sliceTail",id:"slicetail",children:[{value:"Parameters",id:"parameters-20",children:[]},{value:"Usage",id:"usage-21",children:[]}]},{value:"sliceMin",id:"slicemin",children:[{value:"Parameters",id:"parameters-21",children:[]},{value:"Usage",id:"usage-22",children:[]}]},{value:"sliceMax",id:"slicemax",children:[{value:"Parameters",id:"parameters-22",children:[]},{value:"Usage",id:"usage-23",children:[]}]},{value:"sliceSample",id:"slicesample",children:[{value:"Parameters",id:"parameters-23",children:[]},{value:"Usage",id:"usage-24",children:[]}]},{value:"summarize",id:"summarize",children:[{value:"Parameters",id:"parameters-24",children:[]},{value:"Usage",id:"usage-25",children:[]}]},{value:"summarizeAll",id:"summarizeall",children:[{value:"Parameters",id:"parameters-25",children:[]},{value:"Usage",id:"usage-26",children:[]}]},{value:"summarizeAt",id:"summarizeat",children:[{value:"Parameters",id:"parameters-26",children:[]},{value:"Usage",id:"usage-27",children:[]}]},{value:"summarizeIf",id:"summarizeif",children:[{value:"Parameters",id:"parameters-27",children:[]},{value:"Usage",id:"usage-28",children:[]}]},{value:"tally",id:"tally",children:[{value:"Parameters",id:"parameters-28",children:[]},{value:"Usage",id:"usage-29",children:[]}]},{value:"total",id:"total",children:[{value:"Parameters",id:"parameters-29",children:[]},{value:"Usage",id:"usage-30",children:[]}]},{value:"totalAll",id:"totalall",children:[{value:"Parameters",id:"parameters-30",children:[]},{value:"Usage",id:"usage-31",children:[]}]},{value:"totalAt",id:"totalat",children:[{value:"Parameters",id:"parameters-31",children:[]},{value:"Usage",id:"usage-32",children:[]}]},{value:"totalIf",id:"totalif",children:[{value:"Parameters",id:"parameters-32",children:[]},{value:"Usage",id:"usage-33",children:[]}]},{value:"transmute",id:"transmute",children:[{value:"Parameters",id:"parameters-33",children:[]},{value:"Usage",id:"usage-34",children:[]}]},{value:"when",id:"when",children:[{value:"Parameters",id:"parameters-34",children:[]},{value:"Usage",id:"usage-35",children:[]}]}],c={toc:s};function o(e){var a=e.components,t=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},c,t,{components:a,mdxType:"MDXLayout"}),Object(l.b)("p",null,"Tidy functions are the main function used in a ",Object(l.b)("inlineCode",{parentName:"p"},"tidy(...)")," flow. These are the primary functions to be used when wrangling data. They expect their input to either be a flat list of items."),Object(l.b)("h2",{id:"tidy"},"tidy"),Object(l.b)("p",null,"The main function that starts a tidy flow. Used to chain multiple tidy functions together and to smartly handle working with grouped data. The items it works with must be a flat list."),Object(l.b)("h3",{id:"parameters"},"Parameters"),Object(l.b)("h4",{id:"items"},Object(l.b)("inlineCode",{parentName:"h4"},"items")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"object[]\n")),Object(l.b)("p",null,"The collection of data to work with, a flat array of items."),Object(l.b)("h4",{id:"tidyfns"},Object(l.b)("inlineCode",{parentName:"h4"},"...tidyFns")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| (items: object[]) => object[]\n| groupBy() => any /* with export options specified */\n")),Object(l.b)("p",null,"Any number of functions can be supplied to tidy which will be called as if in a pipeline: the output of function 1 is the input to function 2."),Object(l.b)("p",null,"The typical case is ",Object(l.b)("inlineCode",{parentName:"p"},"(items: object[]) => object[]"),", but ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/groupby"}),Object(l.b)("strong",{parentName:"a"},"groupBy"))," may output something different if you specify an ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/groupby#group-exports"}),"export option"),". If you do export from groupBy, it must be the last function called in the tidy flow."),Object(l.b)("h3",{id:"usage"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo', value: 3 },\n  { str: 'foo', value: 3 },\n  { str: 'foo', value: 1 },\n  { str: 'bar', value: 3 },\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 1 },\n  { str: 'foo', value: 3 },\n  { str: 'bar', value: 7 },\n];\n\ntidy(\n  data,\n  distinct(['str', 'value']),\n  filter((d) => d.value <= 3),\n  summarize({ summedValue: sum('value') })\n);\n// output:\n[{ summedValue: 8 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"additems--addrows"},"addItems / addRows"),Object(l.b)("p",null,"Adds items to the end of a collection."),Object(l.b)("h3",{id:"parameters-1"},"Parameters"),Object(l.b)("h4",{id:"itemstoadd"},Object(l.b)("inlineCode",{parentName:"h4"},"itemsToAdd")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| object \n| object[] \n| (items: object[]) => (object | object[])\n")),Object(l.b)("p",null,"The items to add to the collection or a function that resolves to items to add given the input set."),Object(l.b)("h3",{id:"usage-1"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [{ a: 1 }, { a: 2 }];\n\ntidy(data, addRows({ a: 3 }));\n// output:\n[{ a: 1 }, { a: 2 }, { a: 3 }]\n\ntidy(data, addRows([{ a: 4 }]));\n// output:\n[{ a: 1 }, { a: 2 }, { a: 4 }]\n\ntidy(data, addRows((items) => [{ a: items.length * 10 }]));\n// output:\n[{ a: 1 }, { a: 2 }, { a: 10 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"arrange--sort"},"arrange / sort"),Object(l.b)("p",null,"Sorts items by the specified keys and comparators."),Object(l.b)("h3",{id:"parameters-2"},"Parameters"),Object(l.b)("h4",{id:"comparators"},Object(l.b)("inlineCode",{parentName:"h4"},"comparators")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| ((a: object, b: object) => number) \n| Array<string | ((a: object, b: object) => number)>\n")),Object(l.b)("p",null,"A key or set of keys of the item to sort by, or comparator functions that return -1, 0, or 1 if a < b, a == b, a > b respectively. You can mix and match keys and comparator functions when supplying an array."),Object(l.b)("p",null,"For convenience, you can flip to descending order for keys by wrapping the key string with the ",Object(l.b)("inlineCode",{parentName:"p"},"desc(key: string)")," function."),Object(l.b)("p",null,"You can also sort the values for a key in a pre-specified order with the fixedOrder function:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"fixedOrder(\n  key: string | ((d) => any), \n  order: string[], \n  options: { position: 'start' | 'end' })\n")),Object(l.b)("h3",{id:"usage-2"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo', value: 3 },\n  { str: 'foo', value: 4 },\n  { str: 'bar', value: 2 },\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 5 },\n];\n\ntidy(data, arrange(['str', desc('value')])\n// output:\n[\n  { str: 'bar', value: 5 },\n  { str: 'bar', value: 2 },\n  { str: 'bar', value: 1 },\n  { str: 'foo', value: 4 },\n  { str: 'foo', value: 3 },\n] \n\ntidy(data, arrange((a, b) => a.value - b.value));\n// output:\n[\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 2 },\n  { str: 'foo', value: 3 },\n  { str: 'foo', value: 4 },\n  { str: 'bar', value: 5 },\n] \n\ntidy(data, arrange([fixedOrder('value', [5,4,1,3,2])]));\n// output:\n[\n  { str: 'bar', value: 5 }, // <-- pinned to start\n  { str: 'foo', value: 4 },\n  { str: 'bar', value: 1 },\n  { str: 'foo', value: 3 }, // <-- unsorted items\n  { str: 'bar', value: 2 },\n] \n\ntidy(data, \n  arrange([\n    fixedOrder('value', [5,4,1], { position: 'end' })\n  ]));\n// output:\n[\n  { str: 'foo', value: 3 }, // <-- unsorted items\n  { str: 'bar', value: 2 },\n  { str: 'bar', value: 5 }, // <-- pinned to end\n  { str: 'foo', value: 4 },\n  { str: 'bar', value: 1 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"complete"},"complete"),Object(l.b)("p",null,"Complete a collection with missing combinations of data, can be useful for zero filling data. This is a convenience function that combines ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#expand"}),Object(l.b)("strong",{parentName:"a"},"expand")),", ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#leftjoin"}),Object(l.b)("strong",{parentName:"a"},"leftJoin")),", and ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#replacenully"}),Object(l.b)("strong",{parentName:"a"},"replaceNully")),"."),Object(l.b)("h3",{id:"parameters-3"},"Parameters"),Object(l.b)("h4",{id:"expandkeys"},Object(l.b)("inlineCode",{parentName:"h4"},"expandKeys")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| string[]\n| { [key]: string | any[] | (items: object[]) => any[] }\n")),Object(l.b)("p",null,"The keys to expand the collection to have all combinations of. This can be specified as a single key string, an array of key strings or a key mapping object. The key mapping object maps from keys in the items to either:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"{ a: 'a' }"),": the key name itself. In this case, the values to use for the combinations will be derived from what is in the data currently. "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"{ a: [1, 2, 3, 4] }")," an array of values denoting all possible values for this key, even if they do not occur in the data."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"{ a: fullSeq('a') }")," a function mapping from the items in the collection to an array of all possible values. This is typically used in combination with sequence helper functions like ",Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#fullseq"}),Object(l.b)("strong",{parentName:"a"},"fullSeq")),". ")),Object(l.b)("h4",{id:"replacenullyspec"},Object(l.b)("inlineCode",{parentName:"h4"},"replaceNullySpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{ [key]: any }\n")),Object(l.b)("p",null,"A map from key name to the value that nully values should be replaced with for that key. For example, given an objects of the shape ",Object(l.b)("inlineCode",{parentName:"p"},"{a: number, b: string}"),", the ",Object(l.b)("strong",{parentName:"p"},"replaceNullySpec")," may look like ",Object(l.b)("inlineCode",{parentName:"p"},"{ a: -1, b: 'n/a' }"),". Note you are not required to fill in values for all keys\u2013 any unspecified keys will keep their nully value."),Object(l.b)("h3",{id:"usage-3"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, b: 'b1', c: 100 },\n  { a: 2, b: 'b1', c: 200 },\n  { a: 3, b: 'b1', c: 300 },\n  { a: 1, b: 'b2', c: 101 },\n  { a: 2, b: 'b2', c: 201 },\n];\n\ntidy(data, complete(['a', 'b'], { c: 0 }))\n// output:\n[\n  { a: 1, b: 'b1', c: 100 },\n  { a: 1, b: 'b2', c: 101 },\n  { a: 2, b: 'b1', c: 200 },\n  { a: 2, b: 'b2', c: 201 },\n  { a: 3, b: 'b1', c: 300 },\n  { a: 3, b: 'b2', c: 0 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"count"},"count"),Object(l.b)("p",null,"Tallies the number distinct values for the specified keys and adds the count as a new key (default ",Object(l.b)("inlineCode",{parentName:"p"},"n"),"). Optionally sorts by the count. This is a convenience wrapper around ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/groupby"}),Object(l.b)("strong",{parentName:"a"},"groupBy")),", ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#tally"}),Object(l.b)("strong",{parentName:"a"},"tally")),", and optionally ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#arrange"}),Object(l.b)("strong",{parentName:"a"},"arrange")),"."),Object(l.b)("h3",{id:"parameters-4"},"Parameters"),Object(l.b)("h4",{id:"groupkeys"},Object(l.b)("inlineCode",{parentName:"h4"},"groupKeys")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| (item: object) => any\n| Array<string | (item: object) => any>\n")),Object(l.b)("p",null,"The group keys to pass to ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/groupby"}),Object(l.b)("strong",{parentName:"a"},"groupBy")),". Either a key in the item or an accessor function that returns the grouping value, or an array combining these two options."),Object(l.b)("h4",{id:"options"},Object(l.b)("inlineCode",{parentName:"h4"},"options")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{ \n  name: string = 'n', \n  sort: boolean = false,\n}\n")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"name = 'n'"),": The name of the count value in the resulting items."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"sort = false"),": Whether or not the resulting items should be sorted by the count key descending.")),Object(l.b)("h3",{id:"usage-4"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, b: 10, c: 100 },\n  { a: 1, b: 10, c: 101 },\n  { a: 2, b: 20, c: 200 },\n  { a: 3, b: 30, c: 300 },\n];\n\ntidy(data, count('a'));\n// output:\n[{ a: 1, n: 2 }, { a: 2, n: 1 }, { a: 3, n: 1 }];\n\ntidy(data, count('a', { name: 'count' }))\n// output:\n[\n  { a: 1, count: 2 },\n  { a: 2, count: 1 },\n  { a: 3, count: 1 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"debug"},"debug"),Object(l.b)("p",null,"Logs to the console the current state of the data. For grouped data, each group will be output."),Object(l.b)("p",null,"The data passes through unmodified."),Object(l.b)("h3",{id:"parameters-5"},"Parameters"),Object(l.b)("h4",{id:"label"},Object(l.b)("inlineCode",{parentName:"h4"},"label?")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string\n")),Object(l.b)("p",null,"A label to display along with the debugged output."),Object(l.b)("h4",{id:"options-1"},Object(l.b)("inlineCode",{parentName:"h4"},"options?")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  limit?: number | null,\n  output?: 'log' | 'table'\n}\n")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"limit = 10"),": When non-null, the output is limited to the first n items."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"output = 'table'"),": Switches between console.log or console.table as the output mechanism.")),Object(l.b)("h3",{id:"usage-5"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, b: 10, c: 100 },\n  { a: 2, b: 20, c: 200 },\n];\n\ntidy(data, debug())\n/*\n[tidy.debug] ------------------------------------------------------------------\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (index) \u2502 a \u2502 b  \u2502  c  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    0    \u2502 1 \u2502 10 \u2502 100 \u2502\n\u2502    1    \u2502 2 \u2502 20 \u2502 200 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n*/\n\ntidy(data, debug('test label', { limit: 1 }))\n/*\n[tidy.debug] test label -------------------------------------------------------\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (index) \u2502 a \u2502 b  \u2502  c  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    0    \u2502 1 \u2502 10 \u2502 100 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n*/\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"distinct"},"distinct"),Object(l.b)("p",null,"Removes items with duplicate values for the specified keys. If no keys provided, uses strict equality for comparison. You may also think of this as reducing a dataset to just unique values for the specified columns."),Object(l.b)("h3",{id:"parameters-6"},"Parameters"),Object(l.b)("h4",{id:"keys"},Object(l.b)("inlineCode",{parentName:"h4"},"keys")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */ \n| (item: object) => any\n| Array<string | (item: object) => any>\n")),Object(l.b)("p",null,"The set of keys or accessors to use to compare whether two items in a collection are equal."),Object(l.b)("h3",{id:"usage-6"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo', value: 1 },\n  { str: 'foo', value: 3 },\n  { str: 'far', value: 3 },\n  { str: 'bar', value: 1 },\n  { str: 'foo', value: 3 },\n];\n\ntidy(data, distinct(['str', 'value']))\n// output:\n[\n  { str: 'foo', value: 1 },\n  { str: 'foo', value: 3 },\n  { str: 'far', value: 3 },\n  { str: 'bar', value: 1 },\n]\n\ntidy(data, distinct([(d) => d.str[0], 'value']))\n// output:\n[\n  { str: 'foo', value: 1 },\n  { str: 'foo', value: 3 },\n  { str: 'bar', value: 1 },\n]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"expand"},"expand"),Object(l.b)("p",null,"Expands a collection of items to include all combinations of the specified keys. Non-specified keys will be dropped."),Object(l.b)("h3",{id:"parameters-7"},"Parameters"),Object(l.b)("h4",{id:"expandkeys-1"},Object(l.b)("inlineCode",{parentName:"h4"},"expandKeys")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| string[]\n| { [key]: string | any[] | (items: object[]) => any[] }\n")),Object(l.b)("p",null,"The keys to expand the collection to have all combinations of. This can be specified as a single key string, an array of key strings or a key mapping object. The key mapping object maps from keys in the items to either:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"{ a: 'a' }"),": the key name itself. In this case, the values to use for the combinations will be derived from what is in the data currently. "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"{ a: [1, 2, 3, 4] }")," an array of values denoting all possible values for this key, even if they do not occur in the data."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"{ a: fullSeq('a') }")," a function mapping from the items in the collection to an array of all possible values. This is typically used in combination with sequence helper functions like ",Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#fullseq"}),Object(l.b)("strong",{parentName:"a"},"fullSeq")),". ")),Object(l.b)("h3",{id:"usage-7"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, b: 'b1', c: 100 },\n  { a: 2, b: 'b1', c: 200 },\n  { a: 4, b: 'b1', c: 300 },\n  { a: 1, b: 'b2', c: 101 },\n  { a: 2, b: 'b2', c: 201 },\n];\n\ntidy(data, expand('a'));\n// output:\n[{ a: 1 }, { a: 2 }, { a: 4 }]\n\ntidy(data, expand(['a', 'b']))\n// output:\n[\n  { a: 1, b: 'b1' },\n  { a: 1, b: 'b2' },\n  { a: 2, b: 'b1' },\n  { a: 2, b: 'b2' },\n  { a: 4, b: 'b1' },\n  { a: 4, b: 'b2' },\n] \n\ntidy(data, expand({ a: [1, 2, 3, 4, 5], b: 'b' }))\n// output:\n[\n  { a: 1, b: 'b1' },\n  { a: 1, b: 'b2' },\n  { a: 2, b: 'b1' },\n  { a: 2, b: 'b2' },\n  { a: 3, b: 'b1' },\n  { a: 3, b: 'b2' },\n  { a: 4, b: 'b1' },\n  { a: 4, b: 'b2' },\n  { a: 5, b: 'b1' },\n  { a: 5, b: 'b2' },\n] \n\ntidy(data, expand({ a: fullSeq('a') }));\n// output:\n[{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"fill"},"fill"),Object(l.b)("p",null,"Fills values for the specified keys to match the last seen value in the collection."),Object(l.b)("h3",{id:"parameters-8"},"Parameters"),Object(l.b)("h4",{id:"keys-1"},Object(l.b)("inlineCode",{parentName:"h4"},"keys")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| string[]\n")),Object(l.b)("p",null,"The key or keys in the items to fill in. Only the specified keys will be affected."),Object(l.b)("h3",{id:"usage-8"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, b: null, c: undefined, d: 1 },\n  { a: null, b: 2, c: undefined },\n  { a: null, c: 3, d: 3 },\n  { a: 4, b: 4, c: 4, d: 4 },\n  {},\n  { c: 6 },\n  { c: 7, d: 7 },\n];\n\ntidy(data, fill(['a', 'b', 'c', 'd'])));\n// output:\n[\n  { a: 1, b: null, c: undefined, d: 1 },\n  { a: 1, b: 2, c: undefined, d: 1 },\n  { a: 1, b: 2, c: 3, d: 3 },\n  { a: 4, b: 4, c: 4, d: 4 },\n  { a: 4, b: 4, c: 4, d: 4 },\n  { a: 4, b: 4, c: 6, d: 4 },\n  { a: 4, b: 4, c: 7, d: 7 }\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"filter"},"filter"),Object(l.b)("p",null,"Filters out items from the collection based on the filter fn, similar to ",Object(l.b)("inlineCode",{parentName:"p"},"Array.prototype.filter"),"."),Object(l.b)("h3",{id:"parameters-9"},"Parameters"),Object(l.b)("h4",{id:"filterfn"},Object(l.b)("inlineCode",{parentName:"h4"},"filterFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(item: object, index: number, array: object[]) => boolean\n")),Object(l.b)("p",null,"The predicate function to filter by: items are only kept if it returns true."),Object(l.b)("h3",{id:"usage-9"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [{ value: 1 }, { value: 2 }, { value: 3 }];\n\ntidy(data, filter((d) => d.value % 2 === 1))\n// output:\n[{ value: 1 }, { value: 3 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"groupby"},"groupBy"),Object(l.b)("p",null,"Restructures the data to be nested by the specified group keys then runs a tidy flow on each of the leaf sets. Grouped data can be exported into different shapes via ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#groupexports"}),Object(l.b)("strong",{parentName:"a"},"group export helpers")),", or if not specified, will be ungrouped back to a flat list of items. "),Object(l.b)("p",null,"See the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/groupby"}),Object(l.b)("strong",{parentName:"a"},"groupBy docs"))," for details."),Object(l.b)("h3",{id:"usage-10"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'a', ing: 'x', foo: 'G', value: 1 },\n  { str: 'b', ing: 'x', foo: 'H', value: 100 },\n  { str: 'b', ing: 'x', foo: 'K', value: 200 },\n  { str: 'a', ing: 'y', foo: 'G', value: 2 },\n  { str: 'a', ing: 'y', foo: 'H', value: 3 },\n  { str: 'a', ing: 'y', foo: 'K', value: 4 },\n  { str: 'b', ing: 'y', foo: 'G', value: 300 },\n  { str: 'b', ing: 'z', foo: 'H', value: 400 },\n  { str: 'a', ing: 'z', foo: 'K', value: 5 },\n  { str: 'a', ing: 'z', foo: 'G', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy('str', [\n    summarize({ total: sum('value') })\n  ])\n)\n// output:\n[\n  { str: 'a', total: 21 },\n  { str: 'b', total: 1000 },\n]\n*/\n\ntidy(\n  data,\n  groupBy(['str', 'ing'], [\n    summarize({ total: sum('value') })\n  ])\n)\n// output:\n[\n  { str: 'a', ing: 'x', total: 1 },\n  { str: 'a', ing: 'y', total: 9 },\n  { str: 'a', ing: 'z', total: 11 },\n  { str: 'b', ing: 'x', total: 300 },\n  { str: 'b', ing: 'y', total: 300 },\n  { str: 'b', ing: 'z', total: 400 },\n]\n*/\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"innerjoin"},"innerJoin"),Object(l.b)("p",null,"Performs an inner join on two collections of items."),Object(l.b)("h3",{id:"parameters-10"},"Parameters"),Object(l.b)("h4",{id:"itemstojoin"},Object(l.b)("inlineCode",{parentName:"h4"},"itemsToJoin")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"object[] /* the join dataset */\n")),Object(l.b)("p",null,"The collection of items to join."),Object(l.b)("h4",{id:"options-2"},Object(l.b)("inlineCode",{parentName:"h4"},"options")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  by?:\n  | string /* key in both datasets */\n  | string[]\n  | {\n      [string /* key in join */]: string /* key in original */\n    }\n}\n")),Object(l.b)("p",null,"An options object specifying with the following options:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"strong"},"by"))," The key (",Object(l.b)("inlineCode",{parentName:"li"},"string"),") or keys (",Object(l.b)("inlineCode",{parentName:"li"},"string[]"),") to join the two collections on. This form only works if both sets of data have the same column names. If you need to map more specifically, provide an object mapping from key in the original data set to key in the join dataset. Note that if ",Object(l.b)("inlineCode",{parentName:"li"},"by")," is not provided, then overlapping columns will be autodetected and used.")),Object(l.b)("h3",{id:"usage-11"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, J: 'j', b: 10, c: 100 },\n  { a: 1, J: 'k', b: 60, c: 600 },\n  { a: 1, J: 'J', b: 30, c: 300 },\n  { a: 2, J: 'j', b: 20, c: 200 },\n  { a: 3, J: 'x', b: 50, c: 500 },\n];\n\nconst joinData = [\n  { a: 1, J: 'j', altJ: 'j', x: 'x1', y: 'y1' },\n  { a: 1, J: 'J', altJ: 'J', x: 'x9', y: 'y9' },\n  { a: 2, J: 'j', altJ: 'j', x: 'x2', y: 'y2' },\n];\n\ntidy(data, innerJoin(joinData, { by: ['a', 'J'] }));\n// output:\n[\n  { a: 1, J: 'j', altJ: 'j', b: 10, c: 100, x: 'x1', y: 'y1' },\n  { a: 1, J: 'J', altJ: 'J', b: 30, c: 300, x: 'x9', y: 'y9' },\n  { a: 2, J: 'j', altJ: 'j', b: 20, c: 200, x: 'x2', y: 'y2' },\n] \n\ntidy(data, innerJoin(joinData, { by: { a: 'a', altJ: 'J' } }))\n// output:\n[\n  { a: 1, J: 'j', altJ: 'j', b: 10, c: 100, x: 'x1', y: 'y1' },\n  { a: 1, J: 'J', altJ: 'J', b: 30, c: 300, x: 'x9', y: 'y9' },\n  { a: 2, J: 'j', altJ: 'j', b: 20, c: 200, x: 'x2', y: 'y2' },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"leftjoin"},"leftJoin"),Object(l.b)("p",null,"Performs a left join on two collections of items."),Object(l.b)("h3",{id:"parameters-11"},"Parameters"),Object(l.b)("h4",{id:"itemstojoin-1"},Object(l.b)("inlineCode",{parentName:"h4"},"itemsToJoin")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"object[] /* the join dataset */\n")),Object(l.b)("p",null,"The collection of items to join."),Object(l.b)("h4",{id:"options-3"},Object(l.b)("inlineCode",{parentName:"h4"},"options")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  by?:\n  | string /* key in both datasets */\n  | string[]\n  | {\n      [string /* key in join */]: string /* key in original */\n    }\n}\n")),Object(l.b)("p",null,"An options object specifying with the following options:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"strong"},"by"))," The key (",Object(l.b)("inlineCode",{parentName:"li"},"string"),") or keys (",Object(l.b)("inlineCode",{parentName:"li"},"string[]"),") to join the two collections on. This form only works if both sets of data have the same column names. If you need to map more specifically, provide an object mapping from key in the original data set to key in the join dataset. Note that if ",Object(l.b)("inlineCode",{parentName:"li"},"by")," is not provided, then overlapping columns will be autodetected and used.")),Object(l.b)("h3",{id:"usage-12"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, J: 'j', b: 10, c: 100 },\n  { a: 1, J: 'k', b: 60, c: 600 },\n  { a: 1, J: 'J', b: 30, c: 300 },\n  { a: 2, J: 'j', b: 20, c: 200 },\n  { a: 3, J: 'x', b: 50, c: 500 },\n];\n\nconst joinData = [\n  { a: 1, J: 'j', altJ: 'j', x: 'x1', y: 'y1' },\n  { a: 1, J: 'J', altJ: 'J', x: 'x9', y: 'y9' },\n  { a: 2, J: 'j', altJ: 'j', x: 'x2', y: 'y2' },\n];\n\ntidy(data, leftJoin(joinData, { by: ['a', 'J'] }));\n// output:\n[\n  { a: 1, J: 'j', altJ: 'j', b: 10, c: 100, x: 'x1', y: 'y1' },\n  { a: 1, J: 'k', b: 60, c: 600 },\n  { a: 1, J: 'J', altJ: 'J', b: 30, c: 300, x: 'x9', y: 'y9' },\n  { a: 2, J: 'j', altJ: 'j', b: 20, c: 200, x: 'x2', y: 'y2' },\n  { a: 3, J: 'x', b: 50, c: 500 },\n] \n\ntidy(data, leftJoin(joinData, { by: { a: 'a', altJ: 'J' } }))\n// output:\n[\n  { a: 1, J: 'j', altJ: 'j', b: 10, c: 100, x: 'x1', y: 'y1' },\n  { a: 1, J: 'k', b: 60, c: 600 },\n  { a: 1, J: 'J', altJ: 'J', b: 30, c: 300, x: 'x9', y: 'y9' },\n  { a: 2, J: 'j', altJ: 'j', b: 20, c: 200, x: 'x2', y: 'y2' },\n  { a: 3, J: 'x', b: 50, c: 500 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"map"},"map"),Object(l.b)("p",null,"Maps items from one form to another, similar to ",Object(l.b)("inlineCode",{parentName:"p"},"Array.prototype.map"),"."),Object(l.b)("h3",{id:"parameters-12"},"Parameters"),Object(l.b)("h4",{id:"mapfn"},Object(l.b)("inlineCode",{parentName:"h4"},"mapFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(item: object, index: number, array: object[]) => object\n")),Object(l.b)("p",null,"Takes the current item and returns the new item."),Object(l.b)("h3",{id:"usage-13"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value: 1, nested: { a: 10, b: 100 } },\n  { value: 2, nested: { a: 20, b: 200 } },\n];\n\ntidy(data, map((d) => ({ value: d.value, ...d.nested }));\n)\n// output:\n[\n  { value: 1, a: 10, b: 100 },\n  { value: 2, a: 20, b: 200 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"mutate"},"mutate"),Object(l.b)("p",null,"Modify items by adding new columns/keys, or changing existing ones. This operation goes item by item, if you need to mutate with values across multiple items, use ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutatewithsummary"}),Object(l.b)("strong",{parentName:"a"},"mutateWithSummary")),". "),Object(l.b)("p",null,"See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/item"}),Object(l.b)("strong",{parentName:"a"},"item helpers"))," for utility functions that help with common mutate operations. "),Object(l.b)("h3",{id:"parameters-13"},"Parameters"),Object(l.b)("h4",{id:"mutatespec"},Object(l.b)("inlineCode",{parentName:"h4"},"mutateSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* (possibly new) key in mutated objects */]: \n  | (item: object) => any\n  | any \n}\n")),Object(l.b)("p",null,"A specification showing how to modify values on the items. "),Object(l.b)("p",null,"If the mutate value is a function, it will be passed the an individual item at a time. All mutations specified happen on a single item before moving to the next item. For mutations that require computing across items, use ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutatewithsummary"}),Object(l.b)("strong",{parentName:"a"},"mutateWithSummary")),".  "),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mutate({ isEven: d => d.foo % 2 })\n// items where foo is even have isEven true\n")),Object(l.b)("p",null,"If the mutate value is a single value, it will be assigned directly to each item."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mutate({ type: 'o' })\n// all items have { type: 'o' }\n")),Object(l.b)("p",null,"If the mutate value is an array of values, it will be assigned directly to each item."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mutate({ type: ['o', 'a', 't'] })\n// all items have { type: ['o', 'a', 't'] }\n")),Object(l.b)("p",null,"Note that the order of keys matters. Later keys can reference values from previous keys, e.g.: "),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mutate({ \n  key: () => Math.random(), \n  key2: d => d.key * 5 \n}))\n")),Object(l.b)("h3",{id:"usage-14"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo', value: 3 },\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 7 },\n];\n\ntidy(data, mutate({\n  x2: (d) => d.value * 2,\n  x4: (d) => d.x2 * 2,\n  constant: 99  \n}));\n\n// output:\n[\n  { str: 'foo', value: 3, x2:  6, x4: 12, constant: 99 },\n  { str: 'bar', value: 1, x2:  2, x4:  4, constant: 99 },\n  { str: 'bar', value: 7, x2: 14, x4: 28, constant: 99 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"mutatewithsummary"},"mutateWithSummary"),Object(l.b)("p",null,"Modify items by adding new columns/keys, or changing existing ones. This operation can look across multiple items to produce values, which allows summarizations to be added (e.g. totals). If you only need to mutate individual items, use ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutate"}),Object(l.b)("strong",{parentName:"a"},"mutate")),"."),Object(l.b)("p",null,"See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/vector"}),Object(l.b)("strong",{parentName:"a"},"vector helpers"))," and ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/summary"}),Object(l.b)("strong",{parentName:"a"},"summarizers"))," for utility functions that help with common mutateWithSummary operations. "),Object(l.b)("h3",{id:"parameters-14"},"Parameters"),Object(l.b)("h4",{id:"mutatesummaryspec"},Object(l.b)("inlineCode",{parentName:"h4"},"mutateSummarySpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* (possibly new) key in mutated objects */]: \n  | (items: object[]) => any | any[] \n  | any \n  | any[]  \n}\n")),Object(l.b)("p",null,"A specification showing how to modify values on the items. "),Object(l.b)("p",null,"For each key specified in the ",Object(l.b)("inlineCode",{parentName:"p"},"mutateSummarySpec"),", a vector of mutated values is computed then merged (immutably) back into the items before moving to the next key. If you want to mutate on a per-item basis, use ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutate"}),Object(l.b)("strong",{parentName:"a"},"mutate"))," instead."),Object(l.b)("p",null,"If the mutate value is a function, it will be passed the set of all items in the collection to run against, which allows efficient computing of things like means or totals across the entire dataset. "),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mutateWithSummary({ \n  total: sum('value'),\n  rand: (items) => items.map(d => Math.random())\n})\n// all items have { \n//   total: <sum of value across all items>, \n//   rand: <different random number per item> \n// }\n")),Object(l.b)("p",null,"If the mutate value is a single value, it will be assigned directly to each item."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mutateWithSummary({ type: 'o' })\n// all items have { type: 'o' }\n")),Object(l.b)("p",null,"If the mutate value is an array of values, it will be assigned to the items using matching indices."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mutateWithSummary({ type: ['o', 'a', 't'] })\n// items[0] has { type: 'o' }, \n// items[1] has { type: 'a' },\n// items[2] has { type: 't' },\n")),Object(l.b)("p",null,"Note that the order of keys matters. Later keys can reference values from previous keys, e.g.: "),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"mutateWithSummary({ \n  total: sum('value'), \n  totalSquared: items => items[0].total * items[0].total\n}))\n")),Object(l.b)("h3",{id:"usage-15"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo', value: 3 },\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 7 },\n];\n\ntidy(data, mutateWithSummary({\n  total: sum('value'), // helper summary function 'sum'\n}));\n\n// output:\n[\n  { str: 'foo', value: 3, sum: 11 },\n  { str: 'bar', value: 1, sum: 11 },\n  { str: 'bar', value: 7, sum: 11 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"rename"},"rename"),Object(l.b)("p",null,"Rename keys in a collection."),Object(l.b)("h3",{id:"parameters-15"},"Parameters"),Object(l.b)("h4",{id:"renamespec"},Object(l.b)("inlineCode",{parentName:"h4"},"renameSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{ [oldKey: string]: string /* new key */ }\n")),Object(l.b)("p",null,"A mapping from the old key name to the new, renamed key, similar style to destructuring an object."),Object(l.b)("h3",{id:"usage-16"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, b: 'b10', c: 100 },\n  { a: 2, b: 'b20', c: 200 },\n  { a: 3, b: 'b30', c: 300 },\n];\n\ntidy(data, rename({ b: 'newB', c: 'newC' }));\n// output:\n[\n  { a: 1, newB: 'b10', newC: 100 },\n  { a: 2, newB: 'b20', newC: 200 },\n  { a: 3, newB: 'b30', newC: 300 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"replacenully"},"replaceNully"),Object(l.b)("p",null,"Replaces nully values with what is specified in the spec on a per-key basis."),Object(l.b)("h3",{id:"parameters-16"},"Parameters"),Object(l.b)("h4",{id:"replacenullyspec-1"},Object(l.b)("inlineCode",{parentName:"h4"},"replaceNullySpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"object\n")),Object(l.b)("p",null,"A map from key name to the value that nully values should be replaced with for that key. For example, given an objects of the shape ",Object(l.b)("inlineCode",{parentName:"p"},"{a: number, b: string}"),", the ",Object(l.b)("strong",{parentName:"p"},"replaceNullySpec")," may look like ",Object(l.b)("inlineCode",{parentName:"p"},"{ a: -1, b: 'n/a' }"),". Note you are not required to fill in values for all keys\u2013 any unspecified keys will keep their nully value."),Object(l.b)("h3",{id:"usage-17"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value: 1,         foo: null,      bar: '',   x: 1 },\n  { value: null,      foo: undefined, bar: 'xx', x: 2 },\n  { value: undefined, foo: 0,                    x: 3 },\n];\n\ntidy(data, replaceNully({ value: -1, foo: NaN, bar: 'N/A' }));\n// output:\n[\n  { value: 1,  foo: NaN, bar: '',    x: 1 },\n  { value: -1, foo: NaN, bar: 'xx',  x: 2 },\n  { value: -1, foo: 0,   bar: 'N/A', x: 3 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"select--pick"},"select / pick"),Object(l.b)("p",null,"Select subparts of items. This function can be used to re-order keys or for selecting subselections of keys (similar to pick and omit from lodash)."),Object(l.b)("p",null,"See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/selectors"}),Object(l.b)("strong",{parentName:"a"},"selectors"))," for convenient ways specify keys to select."),Object(l.b)("h3",{id:"parameters-17"},"Parameters"),Object(l.b)("h4",{id:"selectkeys"},Object(l.b)("inlineCode",{parentName:"h4"},"selectKeys")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| (items: T[]) => string[] /* keys of items */\n| Array<string | (items: T[]) => string[]>\n")),Object(l.b)("p",null,"The keys, or functions that resolve to keys to select from the object. If a key is prefixed with ",Object(l.b)("inlineCode",{parentName:"p"},"-"),", it will be removed from the object. If the first argument passed begins with ",Object(l.b)("inlineCode",{parentName:"p"},"-"),", an implicit ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/selectors#everything"}),Object(l.b)("strong",{parentName:"a"},"everything"))," selector will be called first."),Object(l.b)("h3",{id:"usage-18"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { foo: 1, bar: 20, foobar: 300, FoObAR: 90, a: 'a1', b: 'b1' },\n  { foo: 2, bar: 21, foobar: 301, FoObAR: 91, a: 'a2', b: 'b2' },\n  { foo: 3, bar: 22, foobar: 302, FoObAR: 92, a: 'a3', b: 'b3' },\n  { foo: 4, bar: 23, foobar: 303, FoObAR: 93, a: 'a4', b: 'b4' },\n];\n\ntidy(data, select(['a', startsWith('foo'), '-foobar']))\n// output:\n[\n  { a: 'a1', foo: 1, FoObAR: 90 },\n  { a: 'a2', foo: 2, FoObAR: 91 },\n  { a: 'a3', foo: 3, FoObAR: 92 },\n  { a: 'a4', foo: 4, FoObAR: 93 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"slice"},"slice"),Object(l.b)("p",null,"Selects a subset of the data, similar to Array.prototype.slice."),Object(l.b)("h3",{id:"parameters-18"},"Parameters"),Object(l.b)("h4",{id:"start"},Object(l.b)("inlineCode",{parentName:"h4"},"start")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"number\n")),Object(l.b)("p",null,"The starting index to select from. The item at this index is included in the results."),Object(l.b)("h4",{id:"end"},Object(l.b)("inlineCode",{parentName:"h4"},"end")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"number\n")),Object(l.b)("p",null,"The ending index before which to end selecting. The item at this index is ",Object(l.b)("em",{parentName:"p"},"not")," included in the results."),Object(l.b)("h3",{id:"usage-19"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value: 1 },\n  { value: 2 },\n  { value: 3 },\n  { value: 4 },\n  { value: 5 },\n];\n\ntidy(data, slice(1, 3))\n// output:\n[{ value: 2 }, { value: 3 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"slicehead"},"sliceHead"),Object(l.b)("p",null,"Selects the first N items in the collection."),Object(l.b)("h3",{id:"parameters-19"},"Parameters"),Object(l.b)("h4",{id:"n"},Object(l.b)("inlineCode",{parentName:"h4"},"n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"number\n")),Object(l.b)("p",null,"The number of items to select."),Object(l.b)("h3",{id:"usage-20"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value: 1 },\n  { value: 2 },\n  { value: 3 },\n  { value: 4 },\n  { value: 5 },\n];\n\ntidy(data, sliceHead(2))\n// output:\n[{ value: 1 }, { value: 2 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"slicetail"},"sliceTail"),Object(l.b)("p",null,"Selects the last N items in the collection."),Object(l.b)("h3",{id:"parameters-20"},"Parameters"),Object(l.b)("h4",{id:"n-1"},Object(l.b)("inlineCode",{parentName:"h4"},"n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"number\n")),Object(l.b)("p",null,"The number of items to select."),Object(l.b)("h3",{id:"usage-21"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value: 1 },\n  { value: 2 },\n  { value: 3 },\n  { value: 4 },\n  { value: 5 },\n];\n\ntidy(data, sliceTail(2))\n// output:\n[{ value: 4 }, { value: 5 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"slicemin"},"sliceMin"),Object(l.b)("p",null,"Selects the minimum N items in the collection ordered by some comparators, similar to ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#arrange"}),Object(l.b)("strong",{parentName:"a"},"arrange")),"."),Object(l.b)("h3",{id:"parameters-21"},"Parameters"),Object(l.b)("h4",{id:"n-2"},Object(l.b)("inlineCode",{parentName:"h4"},"n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"number\n")),Object(l.b)("p",null,"The number of items to select."),Object(l.b)("h4",{id:"orderby"},Object(l.b)("inlineCode",{parentName:"h4"},"orderBy")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| ((a: object, b: object) => number) \n| Array<string | ((a: object, b: object) => number)>\n")),Object(l.b)("p",null,"A key or set of keys of the item to sort by, or comparator functions that return -1, 0, or 1 if a < b, a == b, a > b respectively. See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#arrange"}),Object(l.b)("strong",{parentName:"a"},"arrange"))," for details."),Object(l.b)("h3",{id:"usage-22"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value: 3 },\n  { value: 1 },\n  { value: 4 },\n  { value: 5 },\n  { value: 2 },\n];\n\ntidy(data, sliceMin(2, 'value'))\n// output:\n[{ value: 1 }, { value: 2 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"slicemax"},"sliceMax"),Object(l.b)("p",null,"Selects the maximum N items in the collection ordered by some comparators, similar to ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#arrange"}),Object(l.b)("strong",{parentName:"a"},"arrange")),"."),Object(l.b)("h3",{id:"parameters-22"},"Parameters"),Object(l.b)("h4",{id:"n-3"},Object(l.b)("inlineCode",{parentName:"h4"},"n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"number\n")),Object(l.b)("p",null,"The number of items to select."),Object(l.b)("h4",{id:"orderby-1"},Object(l.b)("inlineCode",{parentName:"h4"},"orderBy")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| ((a: object, b: object) => number) \n| Array<string | ((a: object, b: object) => number)>\n")),Object(l.b)("p",null,"A key or set of keys of the item to sort by, or comparator functions that return -1, 0, or 1 if a < b, a == b, a > b respectively. See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#arrange"}),Object(l.b)("strong",{parentName:"a"},"arrange"))," for details."),Object(l.b)("h3",{id:"usage-23"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value: 3 },\n  { value: 1 },\n  { value: 4 },\n  { value: 5 },\n  { value: 2 },\n];\n\ntidy(data, sliceMax(2, 'value'))\n// output:\n[{ value: 5 }, { value: 4 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"slicesample"},"sliceSample"),Object(l.b)("p",null,"Selects the a random sample of N items in the collection."),Object(l.b)("h3",{id:"parameters-23"},"Parameters"),Object(l.b)("h4",{id:"n-4"},Object(l.b)("inlineCode",{parentName:"h4"},"n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"number\n")),Object(l.b)("p",null,"The number of items to select."),Object(l.b)("h4",{id:"options-4"},Object(l.b)("inlineCode",{parentName:"h4"},"options?")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{ \n  replace?: boolean = false\n}\n")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"replace = false"),": If true, samples items with replacement, otherwise without. If using with replacement, you can sample more than the items that are available.")),Object(l.b)("h3",{id:"usage-24"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value: 1 },\n  { value: 2 },\n  { value: 3 },\n  { value: 4 },\n  { value: 5 },\n];\n\ntidy(data, sliceSample(2))\n// output:\n[{ value: 4 }, { value: 1 }]\n\ntidy(data, sliceSample(4, { replace: true }))\n// output:\n[{ value: 3 }, { value: 3 }, { value: 2 }, { value: 5 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"summarize"},"summarize"),Object(l.b)("p",null,"Takes a collection of items and reduces them to a single item, commonly used for computing averages or sums across a group or dataset."),Object(l.b)("h3",{id:"parameters-24"},"Parameters"),Object(l.b)("h4",{id:"summarizespec"},Object(l.b)("inlineCode",{parentName:"h4"},"summarizeSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* key in output */]: (items: object[]) => any\n}\n")),Object(l.b)("p",null,"An object specifying how to compute the summarized values in the output. The output object matches the keys in this specification with their values set to the output of their respective functions in the spec. Typically the values make use of the provided ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"./summary"}),Object(l.b)("strong",{parentName:"a"},"summarizers")),", but can be anything."),Object(l.b)("p",null,"For example:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"tidy(\n  [{ value: 2 }, { value: 4 }], \n  summarize({ \n    summed: sum('value'), \n    avg: mean('value') \n  }))\n// output:\n[{ summed: 6, avg: 3 }]\n")),Object(l.b)("p",null,"Note that keys not specified will be dropped from the output unless the ",Object(l.b)("inlineCode",{parentName:"p"},"rest")," option is provided."),Object(l.b)("h4",{id:"options-5"},Object(l.b)("inlineCode",{parentName:"h4"},"options")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  rest?: (key: string) => (items: object[]) => any\n}\n")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"rest"),": When provided, all keys in the source objects that are not in the ",Object(l.b)("inlineCode",{parentName:"li"},"summarySpec")," will be resolved via the function that is provided. This is equivalent to specifying all of them in the ",Object(l.b)("inlineCode",{parentName:"li"},"summarySpec"),". Typically this is combined with ",Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"./summary#first"}),Object(l.b)("strong",{parentName:"a"},"first"))," or ",Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"./summary#last"}),Object(l.b)("strong",{parentName:"a"},"last")),":")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"tidy(\n  [{ value: 2 }, { value: 4 }], \n  summarize(\n    { summed: sum('value') }, \n    { rest: first }\n  ))\n// output:\n[{ summed: 6, value: 2 }]\n")),Object(l.b)("h3",{id:"usage-25"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo', value: 3 },\n  { str: 'foo', value: 1 },\n  { str: 'bar', value: 3 },\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 7 },\n];\n\ntidy(data, summarize({\n  summedValue: sum('value'),\n  secondValue: (items) => items[1].value\n}))\n// output:\n[{ summedValue: 15, secondValue: 1 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"summarizeall"},"summarizeAll"),Object(l.b)("p",null,"A simpler form of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarize"}),Object(l.b)("strong",{parentName:"a"},"summarize"))," where all keys in the data are summarized via the specified function."),Object(l.b)("h3",{id:"parameters-25"},"Parameters"),Object(l.b)("h4",{id:"summaryfn"},Object(l.b)("inlineCode",{parentName:"h4"},"summaryFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(key: string) => (items: any[]) => any /* typically number */\n")),Object(l.b)("p",null,"The function to apply to each key in the source data to create the summarized output."),Object(l.b)("h3",{id:"usage-26"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value2: 3, value: 3 },\n  { value2: 4, value: 1 },\n  { value2: 5, value: 3 },\n  { value2: 1, value: 1 },\n  { value2: 10, value: 7 },\n];\n\ntidy(data, summarizeAll(sum))\n// output:\n[{ value: 15, value2: 23 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"summarizeat"},"summarizeAt"),Object(l.b)("p",null,"A simpler form of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarize"}),Object(l.b)("strong",{parentName:"a"},"summarize"))," where the specified keys are summarized via the same specified function. All other keys are dropped."),Object(l.b)("h3",{id:"parameters-26"},"Parameters"),Object(l.b)("h4",{id:"keys-2"},Object(l.b)("inlineCode",{parentName:"h4"},"keys")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"Array<\n  | string /* keys in the object */  \n  | (items: T[]) => string[]\n>\n")),Object(l.b)("p",null,"The keys on which the summary function will be applied. You can either provide the keys directly as strings or you can use ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/selectors"}),Object(l.b)("strong",{parentName:"a"},"selectors")),", or a combination of the two."),Object(l.b)("h4",{id:"summaryfn-1"},Object(l.b)("inlineCode",{parentName:"h4"},"summaryFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(key: string) => (items: any[]) => any /* typically number */\n")),Object(l.b)("p",null,"The function to apply to each key in the source data to create the summarized output."),Object(l.b)("h3",{id:"usage-27"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo1', value2: 3, value: 3 },\n  { str: 'bar1', value2: 4, value: 1 },\n  { str: 'baz1', value2: 5, value: 3 },\n  { str: 'foo2', value2: 1, value: 1 },\n  { str: 'bar2', value2: 10, value: 7 },\n];\n\ntidy(data, summarizeAt(['value', 'value2'], sum))\n// output:\n[{ value: 15, value2: 23 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"summarizeif"},"summarizeIf"),Object(l.b)("p",null,"A simpler form of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarize"}),Object(l.b)("strong",{parentName:"a"},"summarize"))," where the summary function is called on keys whose values pass the specified predicate."),Object(l.b)("h3",{id:"parameters-27"},"Parameters"),Object(l.b)("h4",{id:"predicatefn"},Object(l.b)("inlineCode",{parentName:"h4"},"predicateFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(vector: any[] /* array of single values */) => boolean\n")),Object(l.b)("p",null,"A function that given a vector of values for a key (e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"items.map(item => item.value)"),"), returns true if that key should be summarized."),Object(l.b)("h4",{id:"summaryfn-2"},Object(l.b)("inlineCode",{parentName:"h4"},"summaryFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(key: string) => (items: any[]) => any /* typically number */\n")),Object(l.b)("p",null,"The function to apply to each key in the source data to create the summarized output."),Object(l.b)("h3",{id:"usage-28"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo1', value2: 3, value: 3 },\n  { str: 'bar1', value2: 4, value: 1 },\n  { str: 'baz1', value2: 5, value: 3 },\n  { str: 'foo2', value2: 1, value: 1 },\n  { str: 'bar2', value2: 10, value: 7 },\n];\n\n// if first value for a key is numeric, summarize that column\ntidy(data, summarizeIf((vector) => Number.isFinite(vector[0]), sum)\n// output:\n[{ value: 15, value2: 23 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"tally"},"tally"),Object(l.b)("p",null,"Tally is a wrapper that summarizes the data with ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/summary#n"}),Object(l.b)("strong",{parentName:"a"},"n")),": counts the number of items (per group if grouped)."),Object(l.b)("h3",{id:"parameters-28"},"Parameters"),Object(l.b)("h4",{id:"options-6"},Object(l.b)("inlineCode",{parentName:"h4"},"options")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{ \n  name: string = 'n', \n}\n")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"name = 'n'"),": The name of the count value in the resulting items.")),Object(l.b)("h3",{id:"usage-29"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { a: 1, b: 10, c: 100 },\n  { a: 2, b: 20, c: 200 },\n  { a: 3, b: 30, c: 300 },\n];\n\ntidy(data, tally());\n// [{ n: 3 }]\n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"total"},"total"),Object(l.b)("p",null,"Convenience wrapper around ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarize"}),Object(l.b)("strong",{parentName:"a"},"summarize"))," and ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutate"}),Object(l.b)("strong",{parentName:"a"},"mutate"))," that appends a new summarized row to the end of the data. Typically used for computing totals."),Object(l.b)("h3",{id:"parameters-29"},"Parameters"),Object(l.b)("h4",{id:"summarizespec-1"},Object(l.b)("inlineCode",{parentName:"h4"},"summarizeSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* key in output */]: (items: object[]) => any\n}\n")),Object(l.b)("p",null,"The same as ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarizespec"}),Object(l.b)("strong",{parentName:"a"},"summarize"),"::summarizeSpec")," \u2013  an object specifying how to compute the summarized values in the output. In this case, the expectation is the keys match the input data."),Object(l.b)("h4",{id:"mutatespec-1"},Object(l.b)("inlineCode",{parentName:"h4"},"mutateSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* (possibly new) key in mutated objects */]: \n  | (item: object) => any\n  | any \n}\n")),Object(l.b)("p",null,"A specification showing how to modify values on the items. See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutatespec"}),Object(l.b)("strong",{parentName:"a"},"mutate"))," for details. Can be useful for setting a field that indicates this is a total row (e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"{ id: '__total' }"),")."),Object(l.b)("h3",{id:"usage-30"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo', value: 3 },\n  { str: 'foo', value: 1 },\n  { str: 'bar', value: 3 },\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 7 },\n];\ntidy(data, total(\n  { value: sum('value') },\n  { str: 'total' }\n))\n// output:\n[\n  { str: 'foo', value: 3 },\n  { str: 'foo', value: 1 },\n  { str: 'bar', value: 3 },\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 7 },\n  { str: 'total', value: 15 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"totalall"},"totalAll"),Object(l.b)("p",null,"A simpler form of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#total"}),Object(l.b)("strong",{parentName:"a"},"total")),", but uses ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarizeall"}),Object(l.b)("strong",{parentName:"a"},"summarizeAll"))," instead of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarize"}),Object(l.b)("strong",{parentName:"a"},"summarize")),"."),Object(l.b)("h3",{id:"parameters-30"},"Parameters"),Object(l.b)("h4",{id:"summaryfn-3"},Object(l.b)("inlineCode",{parentName:"h4"},"summaryFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(key: string) => (items: any[]) => any /* typically number */\n")),Object(l.b)("p",null,"The function to apply to each key in the source data to create the summarized output."),Object(l.b)("h4",{id:"mutatespec-2"},Object(l.b)("inlineCode",{parentName:"h4"},"mutateSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* (possibly new) key in mutated objects */]: \n  | (item: object) => any\n  | any \n}\n")),Object(l.b)("p",null,"A specification showing how to modify values on the items.  See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutatespec"}),Object(l.b)("strong",{parentName:"a"},"mutate"))," for details. Can be useful for setting a field that indicates this is a total row (e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"{ id: '__total' }"),")."),Object(l.b)("h3",{id:"usage-31"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { value2: 3, value: 3 },\n  { value2: 4, value: 1 },\n  { value2: 5, value: 3 },\n  { value2: 1, value: 1 },\n  { value2: 10, value: 7 },\n];\n\ntidy(data, totalAll(\n  { value: sum('value') },\n  { str: 'total' }\n))\n// output:\n[\n  { value2: 3, value: 3 },\n  { value2: 4, value: 1 },\n  { value2: 5, value: 3 },\n  { value2: 1, value: 1 },\n  { value2: 10, value: 7 },\n  { value: 15, value2: 23, str: 'total' },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"totalat"},"totalAt"),Object(l.b)("p",null,"A simpler form of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#total"}),Object(l.b)("strong",{parentName:"a"},"total")),", but uses ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarizeat"}),Object(l.b)("strong",{parentName:"a"},"summarizeAt"))," instead of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarize"}),Object(l.b)("strong",{parentName:"a"},"summarize")),"."),Object(l.b)("h3",{id:"parameters-31"},"Parameters"),Object(l.b)("h4",{id:"keys-3"},Object(l.b)("inlineCode",{parentName:"h4"},"keys")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"Array<\n  | string /* keys in the object */  \n  | (items: T[]) => string[]\n>\n")),Object(l.b)("p",null,"The keys on which the summary function will be applied. You can either provide the keys directly as strings or you can use ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"/tidy/docs/api/selectors"}),Object(l.b)("strong",{parentName:"a"},"selectors")),", or a combination of the two."),Object(l.b)("h4",{id:"summaryfn-4"},Object(l.b)("inlineCode",{parentName:"h4"},"summaryFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(key: string) => (items: any[]) => any /* typically number */\n")),Object(l.b)("p",null,"The function to apply to each key in the source data to create the summarized output."),Object(l.b)("h4",{id:"mutatespec-3"},Object(l.b)("inlineCode",{parentName:"h4"},"mutateSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* (possibly new) key in mutated objects */]: \n  | (item: object) => any\n  | any \n}\n")),Object(l.b)("p",null,"A specification showing how to modify values on the items.  See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutatespec"}),Object(l.b)("strong",{parentName:"a"},"mutate"))," for details. Can be useful for setting a field that indicates this is a total row (e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"{ id: '__total' }"),")."),Object(l.b)("h3",{id:"usage-32"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo1', value2: 3, value: 3 },\n  { str: 'bar1', value2: 4, value: 1 },\n  { str: 'baz1', value2: 5, value: 3 },\n  { str: 'foo2', value2: 1, value: 1 },\n  { str: 'bar2', value2: 10, value: 7 },\n];\n\ntidy(data, totalAt(\n  ['value', 'value2'], \n  sum,\n  { str: 'total' }\n))\n// output:\n[\n  { str: 'foo1', value2: 3, value: 3 },\n  { str: 'bar1', value2: 4, value: 1 },\n  { str: 'baz1', value2: 5, value: 3 },\n  { str: 'foo2', value2: 1, value: 1 },\n  { str: 'bar2', value2: 10, value: 7 },\n  { str: 'total', value: 15, value2: 23 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"totalif"},"totalIf"),Object(l.b)("p",null,"A simpler form of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#total"}),Object(l.b)("strong",{parentName:"a"},"total")),", but uses ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarizeif"}),Object(l.b)("strong",{parentName:"a"},"summarizeIf"))," instead of ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#summarize"}),Object(l.b)("strong",{parentName:"a"},"summarize")),"."),Object(l.b)("h3",{id:"parameters-32"},"Parameters"),Object(l.b)("h4",{id:"predicatefn-1"},Object(l.b)("inlineCode",{parentName:"h4"},"predicateFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(vector: any[] /* array of single values */) => boolean\n")),Object(l.b)("p",null,"A function that given a vector of values for a key (e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"items.map(item => item.value)"),"), returns true if that key should be summarized."),Object(l.b)("h4",{id:"summaryfn-5"},Object(l.b)("inlineCode",{parentName:"h4"},"summaryFn")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"(key: string) => (items: any[]) => any /* typically number */\n")),Object(l.b)("p",null,"The function to apply to each key in the source data to create the summarized output."),Object(l.b)("h4",{id:"mutatespec-4"},Object(l.b)("inlineCode",{parentName:"h4"},"mutateSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* (possibly new) key in mutated objects */]: \n  | (item: object) => any\n  | any \n}\n")),Object(l.b)("p",null,"A specification showing how to modify values on the items.  See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutatespec"}),Object(l.b)("strong",{parentName:"a"},"mutate"))," for details. Can be useful for setting a field that indicates this is a total row (e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"{ id: '__total' }"),")."),Object(l.b)("h3",{id:"usage-33"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo1', value2: 3, value: 3 },\n  { str: 'bar1', value2: 4, value: 1 },\n  { str: 'baz1', value2: 5, value: 3 },\n  { str: 'foo2', value2: 1, value: 1 },\n  { str: 'bar2', value2: 10, value: 7 },\n];\n\ntidy(data, totalIf(\n  (vector) => Number.isFinite(vector[0]), \n  sum,\n  { str: 'total' }\n))\n// output:\n[\n  { str: 'foo1', value2: 3, value: 3 },\n  { str: 'bar1', value2: 4, value: 1 },\n  { str: 'baz1', value2: 5, value: 3 },\n  { str: 'foo2', value2: 1, value: 1 },\n  { str: 'bar2', value2: 10, value: 7 },\n  { str: 'total', value: 15, value2: 23 },\n] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"transmute"},"transmute"),Object(l.b)("p",null,"The same as ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutate"}),Object(l.b)("strong",{parentName:"a"},"mutate")),", except all keys are dropped except those specified to be mutated."),Object(l.b)("h3",{id:"parameters-33"},"Parameters"),Object(l.b)("h4",{id:"mutatespec-5"},Object(l.b)("inlineCode",{parentName:"h4"},"mutateSpec")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"{\n  [string /* (possibly new) key in mutated objects */]: \n  | (item: object) => any\n  | any \n}\n")),Object(l.b)("p",null,"A specification showing how to modify values on the items. See ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#mutatespec"}),Object(l.b)("strong",{parentName:"a"},"mutate"))," for details."),Object(l.b)("h3",{id:"usage-34"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'foo', value: 3 },\n  { str: 'bar', value: 1 },\n  { str: 'bar', value: 7 },\n];\n\ntidy(data, transmute({\n  value_x2: (d) => d.value * 2,\n  value_x4: (d) => d.value_x2 * 2,\n}));\n// output:\n[\n    { value_x2: 6, value_x4: 12 },\n    { value_x2: 2, value_x4: 4 },\n    { value_x2: 14, value_x4: 28 },\n  ] \n")),Object(l.b)("hr",null),Object(l.b)("h2",{id:"when"},"when"),Object(l.b)("p",null,"Conditionally runs a tidy subflow based on the result of a boolean or predicate function."),Object(l.b)("h3",{id:"parameters-34"},"Parameters"),Object(l.b)("h4",{id:"predicate"},Object(l.b)("inlineCode",{parentName:"h4"},"predicate")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"| boolean\n| (items: object[]) => boolean\n")),Object(l.b)("p",null,"When true, or the function results in true, the subflow is run, otherwise the input items are passed through unmodified."),Object(l.b)("h4",{id:"fns"},Object(l.b)("inlineCode",{parentName:"h4"},"fns")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"Array<(items: object[]) => object[]>\n")),Object(l.b)("p",null,"Array of tidy functions to run on the input data when the predicate is true."),Object(l.b)("h3",{id:"usage-35"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const data = [{ x: 1 }, { x: 2 }, { x: 3 }];\ntidy(data, \n  when(true, [\n    mutate({ y: 52 })\n  ])\n);\n// output:\n[{ x: 1, y: 52 }, { x: 2, y: 52 }, { x: 3, y: 52 }]\n\ntidy(data,\n  when((items) => items.length === 2, [\n    mutate({ y: 52 })\n  ])\n);\n// output:\n[{ x: 1 }, { x: 2 }, { x: 3 }]\n")),Object(l.b)("hr",null))}o.isMDXComponent=!0},97:function(e,a,t){"use strict";t.d(a,"a",(function(){return u})),t.d(a,"b",(function(){return d}));var n=t(0),r=t.n(n);function l(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function b(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?b(Object(t),!0).forEach((function(a){l(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):b(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),o=function(e){var a=r.a.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},u=function(e){var a=o(e.components);return r.a.createElement(c.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return r.a.createElement(r.a.Fragment,{},a)}},p=r.a.forwardRef((function(e,a){var t=e.components,n=e.mdxType,l=e.originalType,b=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=o(t),p=n,d=u["".concat(b,".").concat(p)]||u[p]||m[p]||l;return t?r.a.createElement(d,i(i({ref:a},c),{},{components:t})):r.a.createElement(d,i({ref:a},c))}));function d(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var l=t.length,b=new Array(l);b[0]=p;var i={};for(var s in a)hasOwnProperty.call(a,s)&&(i[s]=a[s]);i.originalType=e,i.mdxType="string"==typeof e?e:n,b[1]=i;for(var c=2;c<l;c++)b[c]=t[c];return r.a.createElement.apply(null,b)}return r.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);