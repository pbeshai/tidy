(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{80:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return i})),n.d(t,"default",(function(){return p}));var a=n(3),o=n(7),r=(n(0),n(97)),l={title:"groupBy API",sidebar_label:"Grouping with groupBy"},s={unversionedId:"api/groupby",id:"api/groupby",isDocsHomePage:!1,title:"groupBy API",description:"To work with nested data in tidy, you use the groupBy, which runs a subflow of tidy functions on nested groups of the data and can be exported into different forms.",source:"@site/docs/api/groupby.md",slug:"/api/groupby",permalink:"/tidy/docs/api/groupby",editUrl:"https://github.com/pbeshai/tidy/docs/api/groupby.md",version:"current",lastUpdatedBy:"Noah Veltman",lastUpdatedAt:1715978453,sidebar_label:"Grouping with groupBy",sidebar:"docs",previous:{title:"Tidy Function API",permalink:"/tidy/docs/api/tidy"},next:{title:"Summarizer API",permalink:"/tidy/docs/api/summary"}},i=[{value:"groupBy",id:"groupby",children:[{value:"Parameters",id:"parameters",children:[]},{value:"Usage",id:"usage",children:[]}]},{value:"Group Exports",id:"group-exports",children:[{value:"Group Export Options",id:"group-export-options",children:[]}]},{value:"groupBy.entries()",id:"groupbyentries",children:[]},{value:"groupBy.entriesObject()",id:"groupbyentriesobject",children:[]},{value:"groupBy.grouped()",id:"groupbygrouped",children:[]},{value:"groupBy.keys()",id:"groupbykeys",children:[]},{value:"groupBy.map()",id:"groupbymap",children:[]},{value:"groupBy.object()",id:"groupbyobject",children:[]},{value:"groupBy.values()",id:"groupbyvalues",children:[]},{value:"groupBy.levels()",id:"groupbylevels",children:[]}],u={toc:i};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"To work with nested data in tidy, you use the ",Object(r.b)("strong",{parentName:"p"},"groupBy"),", which runs a subflow of tidy functions on nested groups of the data and can be exported into different forms."),Object(r.b)("h2",{id:"groupby"},"groupBy"),Object(r.b)("p",null,"Restructures the data to be nested by the specified group keys then runs a tidy flow on each of the leaf sets. Grouped data can be exported into different shapes via ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#group-exports"}),Object(r.b)("strong",{parentName:"a"},"group export helpers")),", or if not specified, will be ungrouped back to a flat list of items. "),Object(r.b)("h3",{id:"parameters"},"Parameters"),Object(r.b)("h4",{id:"groupkeys"},Object(r.b)("inlineCode",{parentName:"h4"},"groupKeys")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"| string /* key of item */\n| (item: object) => any\n| Array<string | (item: object) => any>\n")),Object(r.b)("p",null,"Either a key in the item or an accessor function that returns the grouping value, or an array combining these two options."),Object(r.b)("p",null,"Note that the grouping logic uses strict equality ",Object(r.b)("inlineCode",{parentName:"p"},"===")," to see if keys are the same, so if you're using non-primitive values that are equal, but not identical (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},'["foo", "bar"] !== ["foo", "bar"]'),"), they won't be grouped together. In those cases, the current recommendation is specifying ",Object(r.b)("inlineCode",{parentName:"p"},"groupKeys")," as a function that returns a primitive value (e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"(item) => item.arrKey.join('---')"),")."),Object(r.b)("h4",{id:"fns"},Object(r.b)("inlineCode",{parentName:"h4"},"fns")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"Array<(item: object[]) => object[]>\n")),Object(r.b)("p",null,"A tidy subflow: an array of tidy functions to run on the leaf sets of the grouped data."),Object(r.b)("h4",{id:"options"},Object(r.b)("inlineCode",{parentName:"h4"},"options?")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"| {\n    addGroupKeys?: boolean;\n  }\n// or export functions (see below)\n| groupBy.grouped()\n| groupBy.entries()\n| groupBy.entriesObject()\n| groupBy.object()\n| groupBy.map()\n| groupBy.keys()\n| groupBy.values()\n| groupBy.levels()\n")),Object(r.b)("p",null,"Options to configure how groupBy operates:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"addGroupKeys = true"),": Whether to merge group keys back into the objects.")),Object(r.b)("h3",{id:"usage"},"Usage"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'a', ing: 'x', foo: 'G', value: 1 },\n  { str: 'b', ing: 'x', foo: 'H', value: 100 },\n  { str: 'b', ing: 'x', foo: 'K', value: 200 },\n  { str: 'a', ing: 'y', foo: 'G', value: 2 },\n  { str: 'a', ing: 'y', foo: 'H', value: 3 },\n  { str: 'a', ing: 'y', foo: 'K', value: 4 },\n  { str: 'b', ing: 'y', foo: 'G', value: 300 },\n  { str: 'b', ing: 'z', foo: 'H', value: 400 },\n  { str: 'a', ing: 'z', foo: 'K', value: 5 },\n  { str: 'a', ing: 'z', foo: 'G', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy('str', [\n    summarize({ total: sum('value') })\n  ])\n)\n// output:\n[{ str: 'a', total: 21 },\n { str: 'b', total: 1000 }]\n\ntidy(\n  data,\n  groupBy(['str', 'ing'], [\n    summarize({ total: sum('value') })\n  ])\n)\n// output:\n[\n  { str: 'a', ing: 'x', total: 1 },\n  { str: 'a', ing: 'y', total: 9 },\n  { str: 'a', ing: 'z', total: 11 },\n  { str: 'b', ing: 'x', total: 300 },\n  { str: 'b', ing: 'y', total: 300 },\n  { str: 'b', ing: 'z', total: 400 },\n]\n")),Object(r.b)("h2",{id:"group-exports"},"Group Exports"),Object(r.b)("p",null,"The final argument to groupBy can also be an export function:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"groupBy.entries(options?)"),Object(r.b)("li",{parentName:"ul"},"groupBy.entriesObject(options?)"),Object(r.b)("li",{parentName:"ul"},"groupBy.grouped(options?)"),Object(r.b)("li",{parentName:"ul"},"groupBy.keys(options?)"),Object(r.b)("li",{parentName:"ul"},"groupBy.map(options?)"),Object(r.b)("li",{parentName:"ul"},"groupBy.object(options?)"),Object(r.b)("li",{parentName:"ul"},"groupBy.values(options?)")),Object(r.b)("p",null,"The levels export allows combining any of the above at different depths of the tree:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"groupBy.levels(options?)")),Object(r.b)("h3",{id:"group-export-options"},"Group Export Options"),Object(r.b)("p",null,"These functions take options as their argument, which includes the options mentioned above plus some extras specific to exporting:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"{\n  addGroupKeys?: boolean; // from groupBy options\n\n  flat?: boolean;\n  compositeKey?: (keys: any[]) => string;\n  single?: boolean;\n  mapLeaf?: (value: any) => any;\n  mapLeaves?: (values: any[]) => any;\n  mapEntry?: (entry: [any, any], level: number) => any;\n  levels?: (\n    | 'entries'\n    | 'entries-object'\n    | 'object'\n    | 'map'\n    | 'keys'\n    | 'values'\n    | LevelSpec\n  )[];\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"export = 'ungrouped'"),': Specifies how the data should be exported from the groupBy function. If anything besides nully or "ungrouped", the remaining options will be interpreted to inform the output.'),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"flat?"),": if all nested levels should be brought to a single top level"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"compositeKey?"),": when ",Object(r.b)("em",{parentName:"li"},"flat")," is true, how to flatten nested keys (default joins with ",Object(r.b)("inlineCode",{parentName:"li"},'"/"'),")"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"single?"),": whether the leaf sets consist of just one item (typical after summarize). if true, uses the first element in the leaf set instead of an array"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"mapLeaf?"),": operation called on each leaf during export to map it to a different value (default: identity)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"mapLeaves?"),": operation called on each leaf set to map the array of values to a different value. Similar to ",Object(r.b)("inlineCode",{parentName:"li"},"rollup")," from d3-collection nest or d3-array (default: identity)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"mapEntry?"),": ",Object(r.b)("em",{parentName:"li"},'when export = "entries" only')," operation called on entries to map from ","[key, values]"," to whatever the output of this is (e.g. ",Object(r.b)("inlineCode",{parentName:"li"},"{ key, values }"),") (default: identity)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"levels?"),": ",Object(r.b)("em",{parentName:"li"},'required when export = "levels" only')," specifies the export operation for each level of the grouping")),Object(r.b)("h2",{id:"groupbyentries"},"groupBy.entries()"),Object(r.b)("p",null,"Exports the data as entries arrays where the keys are the value of the key for that group level and the values are either nested entries or a flat list of items if it is a leaf set."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'const data = [\n  { str: \'a\', ing: \'x\', foo: \'G\', value: 1 },\n  { str: \'b\', ing: \'x\', foo: \'H\', value: 100 },\n  { str: \'b\', ing: \'x\', foo: \'K\', value: 200 },\n  { str: \'a\', ing: \'y\', foo: \'G\', value: 2 },\n  { str: \'a\', ing: \'y\', foo: \'H\', value: 3 },\n  { str: \'a\', ing: \'y\', foo: \'K\', value: 4 },\n  { str: \'b\', ing: \'y\', foo: \'G\', value: 300 },\n  { str: \'b\', ing: \'z\', foo: \'H\', value: 400 },\n  { str: \'a\', ing: \'z\', foo: \'K\', value: 5 },\n  { str: \'a\', ing: \'z\', foo: \'G\', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy(\'str\', [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.entries())\n)\n// output:\n[\n  ["a", [{"str": "a", "total": 21}]], \n  ["b", [{"str": "b", "total": 1000}]]\n]\n\ntidy(\n  data,\n  groupBy([\'str\', \'ing\'], [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.entries({ single: true }))\n)\n// output:\n[\n  [\n    "a",\n    [\n      ["x", {"str": "a", "ing": "x", "total": 1}],\n      ["y", {"str": "a", "ing": "y", "total": 9}],\n      ["z", {"str": "a", "ing": "z", "total": 11}]\n    ]\n  ],\n  [\n    "b",\n    [\n      ["x", {"str": "b", "ing": "x", "total": 300}],\n      ["y", {"str": "b", "ing": "y", "total": 300}],\n      ["z", {"str": "b", "ing": "z", "total": 400}]\n    ]\n  ]\n]\n')),Object(r.b)("hr",null),Object(r.b)("h2",{id:"groupbyentriesobject"},"groupBy.entriesObject()"),Object(r.b)("p",null,"Exports the data as entries objects ",Object(r.b)("inlineCode",{parentName:"p"},"{ key: string, values: any[] }"),"  where the keys are the value of the key for that group level and the values are either nested entries or a flat list of items if it is a leaf set."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'const data = [\n  { str: \'a\', ing: \'x\', foo: \'G\', value: 1 },\n  { str: \'b\', ing: \'x\', foo: \'H\', value: 100 },\n  { str: \'b\', ing: \'x\', foo: \'K\', value: 200 },\n  { str: \'a\', ing: \'y\', foo: \'G\', value: 2 },\n  { str: \'a\', ing: \'y\', foo: \'H\', value: 3 },\n  { str: \'a\', ing: \'y\', foo: \'K\', value: 4 },\n  { str: \'b\', ing: \'y\', foo: \'G\', value: 300 },\n  { str: \'b\', ing: \'z\', foo: \'H\', value: 400 },\n  { str: \'a\', ing: \'z\', foo: \'K\', value: 5 },\n  { str: \'a\', ing: \'z\', foo: \'G\', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy(\'str\', [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.entriesObject())\n)\n// output:\n[\n  {"key": "a", "values": [{"str": "a", "total": 21}]},\n  {"key": "b", "values": [{"str": "b", "total": 1000}]}\n]\n\ntidy(\n  data,\n  groupBy([\'str\', \'ing\'], [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.entriesObject({ single: true }))\n)\n// output:\n[\n  {\n    "key": "a",\n    "values": [\n      {"key": "x", "values": {"str": "a", "ing": "x", "total": 1}},\n      {"key": "y", "values": {"str": "a", "ing": "y", "total": 9}},\n      {"key": "z", "values": {"str": "a", "ing": "z", "total": 11}}\n    ]\n  },\n  {\n    "key": "b",\n    "values": [\n      {"key": "x", "values": {"str": "b", "ing": "x", "total": 300}},\n      {"key": "y", "values": {"str": "b", "ing": "y", "total": 300}},\n      {"key": "z", "values": {"str": "b", "ing": "z", "total": 400}}\n    ]\n  }\n] \n')),Object(r.b)("hr",null),Object(r.b)("h2",{id:"groupbygrouped"},"groupBy.grouped()"),Object(r.b)("p",null,"Exports the data as a Grouped Map where the keys are tuples ",Object(r.b)("inlineCode",{parentName:"p"},"[keyName, keyValue]")," and the values are either nested Grouped Maps or a flat list of items if it is a leaf set. Note this is similar to ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#groupbymap"}),Object(r.b)("strong",{parentName:"a"},"groupBy.map")),", but it uses a tuple for the keys."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'a', ing: 'x', foo: 'G', value: 1 },\n  { str: 'b', ing: 'x', foo: 'H', value: 100 },\n  { str: 'b', ing: 'x', foo: 'K', value: 200 },\n  { str: 'a', ing: 'y', foo: 'G', value: 2 },\n  { str: 'a', ing: 'y', foo: 'H', value: 3 },\n  { str: 'a', ing: 'y', foo: 'K', value: 4 },\n  { str: 'b', ing: 'y', foo: 'G', value: 300 },\n  { str: 'b', ing: 'z', foo: 'H', value: 400 },\n  { str: 'a', ing: 'z', foo: 'K', value: 5 },\n  { str: 'a', ing: 'z', foo: 'G', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy('str', [\n    summarize({ total: sum('value') })\n  ], groupBy.grouped())\n)\n// output:\nnew Map([\n  [['str', 'a'], [{ str: 'a', total: 21 }]],\n  [['str', 'b'], [{ str: 'b', total: 1000 }]],\n]) \n\ntidy(\n  data,\n  groupBy(['str', 'ing'], [\n    summarize({ total: sum('value') })\n  ], groupBy.grouped({ single: true }))\n)\n// output:\nnew Map([\n  [['str', 'a'], \n   [new Map([\n     [['ing', 'x'], { str: 'a', ing: 'x', total: 1 }],\n     [['ing', 'y'], { str: 'a', ing: 'y', total: 9 }],\n     [['ing', 'z'], { str: 'a', ing: 'z', total: 11 }],\n   ])]],\n\n  [['str', 'b'],\n   [new Map([\n     [['ing', 'x'], { str: 'b', ing: 'x', total: 300 }],\n     [['ing', 'y'], { str: 'b', ing: 'y', total: 300 }],\n     [['ing', 'z'], { str: 'b', ing: 'z', total: 400 }],\n   ])]]\n])\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"groupbykeys"},"groupBy.keys()"),Object(r.b)("p",null,"Exports the data as keys arrays, which are similar to entries except they do not include any of the values. Is this useful? Hard to know."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'a', ing: 'x', foo: 'G', value: 1 },\n  { str: 'b', ing: 'x', foo: 'H', value: 100 },\n  { str: 'b', ing: 'x', foo: 'K', value: 200 },\n  { str: 'a', ing: 'y', foo: 'G', value: 2 },\n  { str: 'a', ing: 'y', foo: 'H', value: 3 },\n  { str: 'a', ing: 'y', foo: 'K', value: 4 },\n  { str: 'b', ing: 'y', foo: 'G', value: 300 },\n  { str: 'b', ing: 'z', foo: 'H', value: 400 },\n  { str: 'a', ing: 'z', foo: 'K', value: 5 },\n  { str: 'a', ing: 'z', foo: 'G', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy('str', [\n    summarize({ total: sum('value') })\n  ], groupBy.keys())\n)\n// output:\n[\"a\", \"b\"]\n\ntidy(\n  data,\n  groupBy(['str', 'ing'], [\n    summarize({ total: sum('value') })\n  ], groupBy.keys({ single: true }))\n)\n// output:\n[[\"a\", [\"x\", \"y\", \"z\"]], \n [\"b\", [\"x\", \"y\", \"z\"]]]\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"groupbymap"},"groupBy.map()"),Object(r.b)("p",null,"Exports the data as Map objects where the keys are the value of the key for that group level and the values are either nested Map objects or a flat list of items if it is a leaf set. Note this is similar to ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#groupbygrouped"}),Object(r.b)("strong",{parentName:"a"},"groupBy.grouped")),", but it doesn't use a tuple for keys."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const data = [\n  { str: 'a', ing: 'x', foo: 'G', value: 1 },\n  { str: 'b', ing: 'x', foo: 'H', value: 100 },\n  { str: 'b', ing: 'x', foo: 'K', value: 200 },\n  { str: 'a', ing: 'y', foo: 'G', value: 2 },\n  { str: 'a', ing: 'y', foo: 'H', value: 3 },\n  { str: 'a', ing: 'y', foo: 'K', value: 4 },\n  { str: 'b', ing: 'y', foo: 'G', value: 300 },\n  { str: 'b', ing: 'z', foo: 'H', value: 400 },\n  { str: 'a', ing: 'z', foo: 'K', value: 5 },\n  { str: 'a', ing: 'z', foo: 'G', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy('str', [\n    summarize({ total: sum('value') })\n  ], groupBy.grouped())\n)\n// output:\nnew Map([\n  ['a', [{ str: 'a', total: 21 }]],\n  ['b', [{ str: 'b', total: 1000 }]],\n]) \n\ntidy(\n  data,\n  groupBy(['str', 'ing'], [\n    summarize({ total: sum('value') })\n  ], groupBy.grouped({ single: true }))\n)\n// output:\nnew Map([\n  ['a', \n   [new Map([\n     ['x', { str: 'a', ing: 'x', total: 1 }],\n     ['y', { str: 'a', ing: 'y', total: 9 }],\n     ['z', { str: 'a', ing: 'z', total: 11 }],\n   ])]],\n\n  ['b',\n   [new Map([\n     ['x', { str: 'b', ing: 'x', total: 300 }],\n     ['y', { str: 'b', ing: 'y', total: 300 }],\n     ['z', { str: 'b', ing: 'z', total: 400 }],\n   ])]]\n])\n")),Object(r.b)("h2",{id:"groupbyobject"},"groupBy.object()"),Object(r.b)("p",null,"Exports the data as objects where the keys are the value of the key for that group level and the values are either nested objects or a flat list of items if it is a leaf set."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'const data = [\n  { str: \'a\', ing: \'x\', foo: \'G\', value: 1 },\n  { str: \'b\', ing: \'x\', foo: \'H\', value: 100 },\n  { str: \'b\', ing: \'x\', foo: \'K\', value: 200 },\n  { str: \'a\', ing: \'y\', foo: \'G\', value: 2 },\n  { str: \'a\', ing: \'y\', foo: \'H\', value: 3 },\n  { str: \'a\', ing: \'y\', foo: \'K\', value: 4 },\n  { str: \'b\', ing: \'y\', foo: \'G\', value: 300 },\n  { str: \'b\', ing: \'z\', foo: \'H\', value: 400 },\n  { str: \'a\', ing: \'z\', foo: \'K\', value: 5 },\n  { str: \'a\', ing: \'z\', foo: \'G\', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy(\'str\', [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.object())\n)\n// output:\n{\n  "a": [{"str": "a", "total": 21}], \n  "b": [{"str": "b", "total": 1000}]\n}\n\ntidy(\n  data,\n  groupBy([\'str\', \'ing\'], [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.object({ single: true }))\n)\n// output:\n{\n  "a": {\n    "x": {"str": "a", "ing": "x", "total": 1},\n    "y": {"str": "a", "ing": "y", "total": 9},\n    "z": {"str": "a", "ing": "z", "total": 11}\n  },\n  "b": {\n    "x": {"str": "b", "ing": "x", "total": 300},\n    "y": {"str": "b", "ing": "y", "total": 300},\n    "z": {"str": "b", "ing": "z", "total": 400}\n  }\n}\n')),Object(r.b)("hr",null),Object(r.b)("h2",{id:"groupbyvalues"},"groupBy.values()"),Object(r.b)("p",null,'Exports the data as values arrays which are similar to entries arrays except they contain no keys. Note if you are just trying to get the values back as a single flat list, you do no need to use any export method as that is the default behavior ("ungrouped").'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'const data = [\n  { str: \'a\', ing: \'x\', foo: \'G\', value: 1 },\n  { str: \'b\', ing: \'x\', foo: \'H\', value: 100 },\n  { str: \'b\', ing: \'x\', foo: \'K\', value: 200 },\n  { str: \'a\', ing: \'y\', foo: \'G\', value: 2 },\n  { str: \'a\', ing: \'y\', foo: \'H\', value: 3 },\n  { str: \'a\', ing: \'y\', foo: \'K\', value: 4 },\n  { str: \'b\', ing: \'y\', foo: \'G\', value: 300 },\n  { str: \'b\', ing: \'z\', foo: \'H\', value: 400 },\n  { str: \'a\', ing: \'z\', foo: \'K\', value: 5 },\n  { str: \'a\', ing: \'z\', foo: \'G\', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy(\'str\', [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.values())\n)\n// output:\n[[{"str": "a", "total": 21}], \n [{"str": "b", "total": 1000}]]\n\ntidy(\n  data,\n  groupBy([\'str\', \'ing\'], [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.values({ single: true }))\n)\n// output:\n[\n  [\n    {"str": "a", "ing": "x", "total": 1},\n    {"str": "a", "ing": "y", "total": 9},\n    {"str": "a", "ing": "z", "total": 11}\n  ],\n  [\n    {"str": "b", "ing": "x", "total": 300},\n    {"str": "b", "ing": "y", "total": 300},\n    {"str": "b", "ing": "z", "total": 400}\n  ]\n]\n')),Object(r.b)("hr",null),Object(r.b)("h2",{id:"groupbylevels"},"groupBy.levels()"),Object(r.b)("p",null,"Exports the data in a different way for each level. The last level specified is used for all remaining levels. You must supply a value for ",Object(r.b)("strong",{parentName:"p"},"levels")," in the options argument."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'const data = [\n  { str: \'a\', ing: \'x\', foo: \'G\', value: 1 },\n  { str: \'b\', ing: \'x\', foo: \'H\', value: 100 },\n  { str: \'b\', ing: \'x\', foo: \'K\', value: 200 },\n  { str: \'a\', ing: \'y\', foo: \'G\', value: 2 },\n  { str: \'a\', ing: \'y\', foo: \'H\', value: 3 },\n  { str: \'a\', ing: \'y\', foo: \'K\', value: 4 },\n  { str: \'b\', ing: \'y\', foo: \'G\', value: 300 },\n  { str: \'b\', ing: \'z\', foo: \'H\', value: 400 },\n  { str: \'a\', ing: \'z\', foo: \'K\', value: 5 },\n  { str: \'a\', ing: \'z\', foo: \'G\', value: 6 },\n]\n\ntidy(\n  data,\n  groupBy([\'str\', \'ing\'], [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.levels({ \n    levels: [\'entries-object\', \'object\'], \n    single: true \n  }))\n)\n// output:\n[\n  { // <-- this level is an "entries object"\n    "key": "a",\n    "values": { // <-- this level is an "object"\n      "x": {"str": "a", "ing": "x", "total": 1},\n      "y": {"str": "a", "ing": "y", "total": 9},\n      "z": {"str": "a", "ing": "z", "total": 11}\n    }\n  },\n  {\n    "key": "b",\n    "values": {\n      "x": {"str": "b", "ing": "x", "total": 300},\n      "y": {"str": "b", "ing": "y", "total": 300},\n      "z": {"str": "b", "ing": "z", "total": 400}\n    }\n  }\n]\n\ntidy(\n  data,\n  groupBy([\'str\', \'ing\'], [\n    summarize({ total: sum(\'value\') })\n  ], groupBy.levels({ \n    levels: [\'object\', \'entries-object\'], // swapped order\n    single: true \n  }))\n)\n// output:\n{ // <-- this level is an "object"\n  "a": [ // <-- this level is "entries object"s\n    {"key": "x", "values": {"str": "a", "ing": "x", "total": 1}},\n    {"key": "y", "values": {"str": "a", "ing": "y", "total": 9}},\n    {"key": "z", "values": {"str": "a", "ing": "z", "total": 11}}\n  ],\n  "b": [\n    {"key": "x", "values": {"str": "b", "ing": "x", "total": 300}},\n    {"key": "y", "values": {"str": "b", "ing": "y", "total": 300}},\n    {"key": "z", "values": {"str": "b", "ing": "z", "total": 400}}\n  ]\n}\n')),Object(r.b)("h4",{id:"custom-levels-export"},"Custom Levels Export"),Object(r.b)("p",null,"For a more advanced export, a custom levels export can be specified by providing a ",Object(r.b)("strong",{parentName:"p"},"LevelSpec")," for the value of ",Object(r.b)("strong",{parentName:"p"},"levels"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// LevelSpec:\n{\n  createEmptySubgroup: () => any;\n  addSubgroup: (\n    parentGrouped: any,\n    newSubgroup: any,\n    key: any,\n    level: number\n  ) => void;\n  addLeaf: (\n    parentGrouped: any, \n    key: any, \n    values: any[], \n    level: number\n  ) => void;\n}\n")),Object(r.b)("p",null,"Probably best to just look at the source code of the existing groupBy methods to get an idea of how to use this."))}p.isMDXComponent=!0},97:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return y}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=o.a.createContext({}),p=function(e){var t=o.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=p(e.components);return o.a.createElement(u.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},c=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),b=p(n),c=a,y=b["".concat(l,".").concat(c)]||b[c]||g[c]||r;return n?o.a.createElement(y,s(s({ref:t},u),{},{components:n})):o.a.createElement(y,s({ref:t},u))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=c;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,l[1]=s;for(var u=2;u<r;u++)l[u]=n[u];return o.a.createElement.apply(null,l)}return o.a.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);